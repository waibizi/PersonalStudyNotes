# 浅谈JVM中的safepoint

​	众所周知，JVM里面的GC Root信息是采用OopMap的记录信息来确定的。而safepoint就是来确定啥时候应该记录OopMap的。

​	safepoint称之为安全点，安全点就是线程运行时的某一个位置，当运行到这个位置的时候，线程的某一些状态可以被确定，可以让用户的线程在此进行挂起。

--the thread's representation of it's Java machine state is well described

​	安全点的设定，也决定了用户程序执行时并不是在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够停止。

安全点的选用基本是以“是否具有让程序长时间执行的特征”为标准进行选定的。

safepoint的设定位置主要有

1.循环的末尾

2.方法返回前

3.调用方法的call之后

4.抛出异常的位置

对于安全点有个需要注意的地方就是，如何在垃圾收集的时候，让所有的线程都能够跑到最近的安全点，然后停顿挂起呢？

有两种选择方案：

1.抢先式中断（Preemptive Suspension）

抢先式中断：就是当发生需要垃圾收集的时候，先中断，然后再查看是不是在安全点，如果不在安全点，重新恢复线程。下次再继续重复此操作，直到垃圾收集的时候刚好在安全点。

2.主动式中断（Voluntary Suspension）

主动式中断：当需要垃圾收集的时候，先打上一个标志位，各个线程会不断地去轮询这个标志，一旦发现标志为真时就在自己最近的安全点上主动挂起线程。

