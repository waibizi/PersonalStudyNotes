# 第九章	集合

Java的集合是面试的高频问，那我们来叨叨Java的集合框架吧

Java的集合类主要由三个接口派生而出，即Collection和Map接口和Iterator接口

 ![image-20200421193045228](E:\实习准备\面试准备\JDK\核心技术卷1\temp\2.png)

从类图中可以看出，List与Set都是实现了Collection接口，而Map不实现Collection接口。







## 面试题

### 1.Java集合框架是什么？说出一些集合框架的优点？

​	每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：

（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。

（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。

（3）通过使用JDK附带的集合类，可以降低代码维护成本。

（4）复用性和可操作性。

### 2.集合框架中的泛型有什么优点？

 	Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。

### 3.Java集合框架的基础接口有哪些？

  **Collection为集合层级的根接口**。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。

  **Set是一个不能包含重复元素的集合**。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。

  **List是一个有序集合，可以包含重复元**素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。

  **Map是一个将key映射到value的对象**.一个Map不能包含重复的key：每个key最多只能映射一个value。

  一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator

### 4.为何Collection不从Cloneable和Serializable接口继承？

  **Collection**接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。

  当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。

  在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。

### 5.为何Map接口不继承Collection接口？

  尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。

  如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。

### 6.Iterator是什么？

  Iterator接口提**供遍历任何Collection的接口**。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。

### 7.Enumeration和Iterator接口的区别？

​	Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。

​	迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。

### 8.为何没有像Iterator.add()这样的方法，向集合中添加元素？

​	语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。

### 9.为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？

​	它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。

### 10.Iterater和ListIterator之间有什么区别？

（1）我们可以使用**Iterator来遍历Set和List集合**，而**ListIterator只能遍历List**。

（2）**Iterator只可以向前遍历**，而**LIstIterator可以双向遍历**。

（3）**ListIterator从Iterator接口继承**，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。

### 11.遍历一个List有哪些不同的方式？
```java
List<String> strList = new ArrayList<>();

//使用for-each循环
for(String obj : strList){
 System.out.println(obj);
}

/使用iterator
Iterator<String> it = strList.iterator();
while(it.hasNext()){
 String obj = it.next();
 System.out.println(obj);
}
```
​	使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。

### 12.通过迭代器fail-fast属性，你明白了什么？

​	每次我们尝试获取下一个元素的时候，Iterator  fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。

### 13.fail-fast与fail-safe有什么区别？

​	Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。

Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。

### 14.在迭代一个集合的时候，如何避免ConcurrentModificationException？

​	在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList

### 15.为何Iterator接口没有具体的实现？

​	Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。

### 16.Collection和Collections的区别

collection 是集合类的上级接口, 继承与它的接口主要是 set 和 list。  

collections 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜索, 排序, 线程安全化等操作。  

### 17.数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是ArrayList？  

Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。
Array 大小是固定的， ArrayList 的大小是动态变化的。
ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。  

### 18.HashSet 的底层实现是什么?  

​	通过看源码知道 HashSet 的实现是依赖于 HashMap 的， HashSet 的值都是存储
在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，
HashSet 不允许值重复，因此， HashSet 的值是作为 HashMap 的 key 存储在
HashMap 中的，当存储的值已经存在时返回 false。  

### 19.为何HashMap的数组长度一定是2的次幂？

​	为了减小索引位置冲突的机率。 

LinkedList

```
public boolean add(E e) {
    linkLast(e);
    return true;
}
 void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
```

